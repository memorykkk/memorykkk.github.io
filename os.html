<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>操作系统引论 | Memorykk | never too late to learn</title>

  
  <meta name="author" content="Memorykk">
  

  
  <meta name="description" content="computer,program,developer,java,linux">
  

  
  <meta name="keywords" content="computer,study,log,tool,fragment,program,developer,java,linux">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="操作系统引论"/>

  <meta property="og:site_name" content="Memorykk"/>

  
  <meta property="og:image" content="/images/favicon.ico"/>
  

  <link href="/images/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Memorykk" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <meta name="baidu-site-verification" content="code-DBwLDCJwuQ" />
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Memorykk</a>
    </h1>
    <p class="site-description">never too late to learn</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/categories">分类</a></li>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/about">关于</a></li>
      
        <li><a href="/atom.xml">订阅</a></li>
      
    </ul>
  </nav>
</header>

    <main  class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>操作系统引论</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/os.html" rel="bookmark">
        <time class="entry-date published" datetime="2021-03-16T07:34:23.000Z">
          2021-03-16
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>准备的书太拉跨，不准备继续总结了</p>
<span id="more"></span>
<hr>
<p><strong>目录</strong></p>
<!-- TOC -->
<ul>
<li><a href="#1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E8%AE%BA">1. 操作系统引论</a><ul>
<li><a href="#1-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%9B%AE%E6%A0%87">1.1. 操作系统的目标</a></li>
<li><a href="#1-2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8">1.2. 操作系统的作用</a></li>
<li><a href="#1-3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E8%BF%87%E7%A8%8B">1.3. 操作系统的发展过程</a><ul>
<li><a href="#1-3-1-%E6%9C%AA%E9%85%8D%E7%BD%AE%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F">1.3.1. 未配置操作系统的计算机系统</a><ul>
<li><a href="#1-3-1-1-%E4%BA%BA%E5%B7%A5%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F">1.3.1.1. 人工操作方式</a></li>
<li><a href="#1-3-1-2-%E8%84%B1%E6%9C%BA%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%96%B9%E5%BC%8F">1.3.1.2. 脱机输入输出方式</a></li>
</ul>
</li>
<li><a href="#1-3-2-%E5%8D%95%E9%81%93%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F">1.3.2. 单道批处理系统</a></li>
<li><a href="#1-3-3-%E5%A4%9A%E9%81%93%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F">1.3.3. 多道批处理系统</a></li>
<li><a href="#1-3-4-%E5%88%86%E6%97%B6%E7%B3%BB%E7%BB%9F">1.3.4. 分时系统</a></li>
<li><a href="#1-3-5-%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F">1.3.5. 实时系统</a></li>
<li><a href="#1-3-6-%E5%BE%AE%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">1.3.6. 微机操作系统</a></li>
</ul>
</li>
<li><a href="#1-4-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7">1.4. 操作系统的基本特性</a><ul>
<li><a href="#1-4-1-%E5%B9%B6%E5%8F%91">1.4.1. 并发</a></li>
<li><a href="#1-4-2-%E5%85%B1%E4%BA%AB">1.4.2. 共享</a></li>
<li><a href="#1-4-3-%E8%99%9A%E6%8B%9F">1.4.3. 虚拟</a></li>
<li><a href="#1-4-4-%E5%BC%82%E6%AD%A5">1.4.4. 异步</a></li>
</ul>
</li>
<li><a href="#1-5-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD">1.5. 操作系统的主要功能</a><ul>
<li><a href="#1-5-1-%E5%A4%84%E7%90%86%E6%9C%BA%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD">1.5.1. 处理机管理功能</a></li>
<li><a href="#1-5-2-%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD">1.5.2. 存储器管理功能</a></li>
<li><a href="#1-5-3-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD">1.5.3. 设备管理功能</a></li>
<li><a href="#1-5-4-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD">1.5.4. 文件管理功能</a></li>
<li><a href="#1-5-5-OS%E4%B8%8E%E7%94%A8%E6%88%B7%E4%B9%8B%E9%97%B4%E7%9A%84%E6%8E%A5%E5%8F%A3">1.5.5. OS与用户之间的接口</a></li>
<li><a href="#1-5-6-%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%96%B0%E5%8A%9F%E8%83%BD">1.5.6. 现代操作系统的新功能</a></li>
</ul>
</li>
<li><a href="#1-6-OS%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1">1.6. OS结构设计</a><ul>
<li><a href="#1-6-1-%E4%BC%A0%E7%BB%9FOS%E7%BB%93%E6%9E%84">1.6.1. 传统OS结构</a><ul>
<li><a href="#1-6-1-1-%E6%97%A0%E7%BB%93%E6%9E%84OS">1.6.1.1. 无结构OS</a></li>
<li><a href="#1-6-1-2-%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BB%93%E6%9E%84OS">1.6.1.2. 模块化结构OS</a></li>
<li><a href="#1-6-1-3-%E5%88%86%E5%B1%82%E5%BC%8F%E7%BB%93%E6%9E%84OS">1.6.1.3. 分层式结构OS</a></li>
</ul>
</li>
<li><a href="#1-6-2-%E5%AE%A2%E6%88%B7%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%BC%8F">1.6.2. 客户服务器模式</a></li>
<li><a href="#1-6-3-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%8A%80%E6%9C%AF">1.6.3. 面向对象的程序设计技术</a></li>
<li><a href="#1-6-4-%E5%BE%AE%E5%86%85%E6%A0%B8OS%E7%BB%93%E6%9E%84">1.6.4. 微内核OS结构</a><ul>
<li><a href="#1-6-4-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">1.6.4.1. 基本概念</a></li>
<li><a href="#1-6-4-2-%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD">1.6.4.2. 基本功能</a></li>
<li><a href="#1-6-4-3-%E4%BC%98%E7%BC%BA%E7%82%B9">1.6.4.3. 优缺点</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0%E4%B8%8E%E6%8E%A7%E5%88%B6">2. 进程的描述与控制</a><ul>
<li><a href="#2-1-%E5%89%8D%E8%B6%8B%E5%9B%BE%E5%92%8C%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C">2.1. 前趋图和程序执行</a><ul>
<li><a href="#2-1-1-%E5%89%8D%E8%B6%8B%E5%9B%BE">2.1.1. 前趋图</a></li>
<li><a href="#2-1-2-%E7%A8%8B%E5%BA%8F%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C">2.1.2. 程序顺序执行</a></li>
<li><a href="#2-1-3-%E7%A8%8B%E5%BA%8F%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C">2.1.3. 程序并发执行</a></li>
</ul>
</li>
<li><a href="#2-2-%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0">2.2. 进程的描述</a><ul>
<li><a href="#2-2-1-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89">2.2.1. 进程的定义</a></li>
<li><a href="#2-2-2-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81">2.2.2. 进程的特征</a></li>
</ul>
</li>
<li><a href="#2-3-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81%E5%8F%8A%E8%BD%AC%E6%8D%A2">2.3. 进程的基本状态及转换</a><ul>
<li><a href="#2-3-1-%E4%B8%89%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81">2.3.1. 三种基本状态</a></li>
<li><a href="#2-3-2-%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2">2.3.2. 状态转换</a></li>
<li><a href="#2-3-3-%E5%88%9B%E5%BB%BA%E7%8A%B6%E6%80%81%E5%92%8C%E7%BB%88%E6%AD%A2%E7%8A%B6%E6%80%81">2.3.3. 创建状态和终止状态</a></li>
</ul>
</li>
<li><a href="#2-4-%E6%8C%82%E8%B5%B7%E6%93%8D%E4%BD%9C">2.4. 挂起操作</a><!-- /TOC --></li>
</ul>
</li>
</ul>
<hr>
<h1 id="1-操作系统引论"><a href="#1-操作系统引论" class="headerlink" title="1. 操作系统引论"></a>1. 操作系统引论</h1><p>操作系统是一组能有效地组织和管理计算机硬件和软件资源，合理地对各类作业进行调度，以及方便用户使用的程序的集合。</p>
<h2 id="1-1-操作系统的目标"><a href="#1-1-操作系统的目标" class="headerlink" title="1.1. 操作系统的目标"></a>1.1. 操作系统的目标</h2><ul>
<li>方便性：裸机上难以使用；</li>
<li>有效性：<strong>提高资源利用率，提高系统吞吐量</strong>；</li>
<li>可扩充性：适应硬件、体系结构发展；</li>
<li>开放性：软硬件的兼容性。</li>
</ul>
<h2 id="1-2-操作系统的作用"><a href="#1-2-操作系统的作用" class="headerlink" title="1.2. 操作系统的作用"></a>1.2. 操作系统的作用</h2><ul>
<li>OS作为用户与计算机硬件系统之间的接口。三种使用方式：系统调用、命令、图形窗口；</li>
<li>OS作为计算机系统资源的管理者。资源分四类：<ul>
<li>处理机：分配和控制处理机：</li>
<li>存储器：内存的分配与回收；</li>
<li>I/O设备：I/O设备的分配与操纵；</li>
<li>文件：文件的存取、共享、保护；</li>
</ul>
</li>
<li>OS实现了对计算机资源的抽象。通过I/O设备管理软件、文件系统、窗口等多层次抽象，使裸机称为更强的虚机器。不仅实现了功能，而且隐藏了细节。</li>
</ul>
<h2 id="1-3-操作系统的发展过程"><a href="#1-3-操作系统的发展过程" class="headerlink" title="1.3. 操作系统的发展过程"></a>1.3. 操作系统的发展过程</h2><h3 id="1-3-1-未配置操作系统的计算机系统"><a href="#1-3-1-未配置操作系统的计算机系统" class="headerlink" title="1.3.1. 未配置操作系统的计算机系统"></a>1.3.1. 未配置操作系统的计算机系统</h3><h4 id="1-3-1-1-人工操作方式"><a href="#1-3-1-1-人工操作方式" class="headerlink" title="1.3.1.1. 人工操作方式"></a>1.3.1.1. 人工操作方式</h4><p>早期的操作方式是由程序员将事先已穿孔的纸带（或卡片），装入纸带输入机（或卡片输入机），再启动它们将纸带（或卡片）上的程序和数据输入计算机，然后启动计算机运行。仅当程序运行完毕并取走计算结果后，才允许下一个用户上机。这种人工操作方式有以下两方面的缺点：</p>
<ol>
<li>用户独占全机，即一台计算机的全部资源由上机用户所独占。</li>
<li>CPU等待人工操作。当用户进行装带（卡）、卸带（卡）等人工操作时，CPU及内存等资源是空闲的。</li>
</ol>
<h4 id="1-3-1-2-脱机输入输出方式"><a href="#1-3-1-2-脱机输入输出方式" class="headerlink" title="1.3.1.2. 脱机输入输出方式"></a>1.3.1.2. 脱机输入输出方式</h4><p>为了解决人机矛盾及CPU和I/O设备之间速度不匹配的矛盾，出现了脱机IO技术。该技术是事先将装有用户程序和数据的纸带装入纸带输入机，在一台外围机的控制下，把纸带（卡片）上的数据（程序）输入到磁带上。当CPU需要这些程序和数据时，再从磁带上高速地调入内存。</p>
<p><img src="/images/os/offLine.png"></p>
<p>由于程序和数据的输入和输出都是在外围机的控制下完成的，或者说，它们是在脱离主机的情况下进行的，故称为脱机输入输出方式。反之，把在主机的直接控制下进行输入输出的方式称为联机输入/输出方式。<br>优点是：</p>
<ul>
<li>减少了CPU的空闲时间：外围机操作并不占用主机时间；</li>
<li>提高了I/O速度。</li>
</ul>
<h3 id="1-3-2-单道批处理系统"><a href="#1-3-2-单道批处理系统" class="headerlink" title="1.3.2. 单道批处理系统"></a>1.3.2. 单道批处理系统</h3><p><strong>处理过程</strong><br>为实现对作业的连续处理，先把一批作业以脱机方式输入到磁带上，配上监督程序。首先由监督程序将磁带上的第一个作业装入内存，并把运行控制权交给该作业；当该作业处理完成时，又把控制权交还给监督程序，再由监督程序把磁带上的第二个作业调入内存。计算机系统就这样自动地一个作业紧接一个作业地进行处理，直至磁带上的所有作业全部完成，这样便形成了早期的批处理系统。虽然系统对作业的处理是成批进行的，但在内存中始终只保持一道作业，故称为单道批处理系统。</p>
<p><img src="/images/os/simpleBatchProcess.png"></p>
<p>旨在解决人机矛盾和CPU与IO设备速度不匹配矛盾的过程中形成的，提高系统资源的利用率和系统吞吐量。</p>
<p><strong>缺点</strong><br>系统中的资源得不到充分的利用。因为在内存中仅有一道程序，每逢该程序在运行中发出I/O请求后，CPU便处于等待状态，必须在其I/O完成后才继续运行。又因I/O设备的低速性，更使CPU的利用率显著降低。</p>
<h3 id="1-3-3-多道批处理系统"><a href="#1-3-3-多道批处理系统" class="headerlink" title="1.3.3. 多道批处理系统"></a>1.3.3. 多道批处理系统</h3><p><strong>处理过程</strong><br>用户所提交的作业先存放在外存上，并排成一个队列，称为“后备队列”。然后由作业调度程序按一定的算法，从后备队列中选择若干个作业调入内存，使它们共享CPU和系统中的各种资源。由于同时在内存中装有若干道程序，这样便可以在运行程序A时，利用其因I/O操作而暂停执行时的CPU空档时间，再调度另一道程序B运行，同样可以利用程序B在I/O操作时的CPU空档时间，再调度程序C运行，使多道程序交替地运行，这样便可以保持CPU处于忙碌状态。</p>
<p><img src="/images/os/multiBatchProcess.png"></p>
<p><strong>优缺点</strong></p>
<ul>
<li>资源利用率高。引入多道批处理能使多道程序交替运行，以保持CPU处于忙碌状态；在内存中装入多道程序可提高内存的利用率；此外还可以提高IO设备的利用率。</li>
<li>系统吞吐量大。能提高系统吞吐量的主要原因可归结为：①CPU和其它资源保持“忙碌”状态；仅当作业完成时或运行不下去时才进行切换，系统开销小。</li>
<li>平均周转时间长。由于作业要排队依次进行处理，因而作业的周转时间较长，通常需几个小时，甚至几天。</li>
<li>无交互能力。用户一旦把作业提交给系统后，直至作业完成，用户都不能调试修改。</li>
</ul>
<p><strong>需要解决的问题</strong></p>
<ul>
<li>处理机争用问题。既要能满足各道程序运行的需要，又要能提高处理机的利用率。</li>
<li>内存分配和保护问题。系统应能为每道程序分配必要的内存空间，使它们“各得其所”，且不会因某道程序出现异常情况而破坏其它程序。</li>
<li>I/O设备分配问题。系统应采取适当的策略来分配系统中的IO设备，以达到既能方便用户对设备的使用，又能提高设备利用率的目的。</li>
<li>文件的组织和管理问题。系统应能有效地组织存放在系统中的大量的程序和数据，使它们既便于用户使用，又能保证数据的安全性。</li>
<li>作业管理问题。系统中存在着各种作业（应用程序），系统应能对系统中所有的作业进行合理的组织，以满足这些作业用户的不同要求</li>
<li>用户与系统的接口问题。为使用户能方便的使用操作系统，OS还应提供用户与操作系统之间的接口。</li>
</ul>
<h3 id="1-3-4-分时系统"><a href="#1-3-4-分时系统" class="headerlink" title="1.3.4. 分时系统"></a>1.3.4. 分时系统</h3><p>为了满足人机交互和共享主机的需求。OS能提供终端，系统及时接收处理命令。</p>
<ul>
<li>及时接收：配置多路卡，实现分时多路复用；</li>
<li>及时处理：<ul>
<li>作业直接进入内存；</li>
<li>采用轮转运行方式。设置时间片避免一个作业长期独占CPU。</li>
</ul>
</li>
</ul>
<p><strong>特征</strong><br>多路性、独立性、及时性、交互性。</p>
<h3 id="1-3-5-实时系统"><a href="#1-3-5-实时系统" class="headerlink" title="1.3.5. 实时系统"></a>1.3.5. 实时系统</h3><p>“实时计算”，则可以定义为这样一类计算：系统的正确性，不仅由计算的逻辑结果来确定，而且还取决于产生结果的时间。实时系统最主要的特征，是将时间作为关键参数。</p>
<p><strong>实时任务的类型</strong></p>
<ul>
<li><p>周期性</p>
</li>
<li><p>非周期性：开始截止时间和完成截止时间</p>
</li>
<li><p>硬实时任务：必须</p>
</li>
<li><p>软实时任务：不严格</p>
</li>
</ul>
<p><strong>实时系统与分时系统特征的比较</strong></p>
<ol>
<li>多路性。分时系统中表现为系统按分时原则为多个终端用户服务：实时控制指系统周期性地对多路现场信息进行采集；</li>
<li>独立性。分时系统每个终端在与系统交互时彼此相互独立互不干扰；实时系统中对信息的采集和对对象的控制也都是彼此互不干扰的</li>
<li>及时性。分时系统对实时性的要求是依据人所能接受的等待时间确定的；实时控制系统的实时性则是以控制对象所要求的截止时间来确定的。<br>（4）交互性。实时系统交互性仅限于访问系统中某些特定的专用服务程序；分时系统能向终端用户提供数据处理、资源共享等服务。<br>（5）可靠性。分时系统要求系统可靠，实时系统要求系统高度可靠。</li>
</ol>
<h3 id="1-3-6-微机操作系统"><a href="#1-3-6-微机操作系统" class="headerlink" title="1.3.6. 微机操作系统"></a>1.3.6. 微机操作系统</h3><ul>
<li>单用户单任务操作系统：MS-DOS</li>
<li>单用户多任务操作系统：windows</li>
<li>多用户多任务操作系统：unix，linux</li>
</ul>
<h2 id="1-4-操作系统的基本特性"><a href="#1-4-操作系统的基本特性" class="headerlink" title="1.4. 操作系统的基本特性"></a>1.4. 操作系统的基本特性</h2><h3 id="1-4-1-并发"><a href="#1-4-1-并发" class="headerlink" title="1.4.1. 并发"></a>1.4.1. 并发</h3><ol>
<li>并行与并发</li>
</ol>
<p>并行性是指两个或多个事件在同一时刻发生。而并发性是指两个或多个事件在同一时间间隔内发生。在多道程序环境下，并发性是指在一段时间内宏观上有多个程序在同时运行，但在单处理机系统中，每一时刻却仅能有一道程序执行，故微观上这些程序只能是分时地交替执行。</p>
<ol start="2">
<li>引入进程<br>在一个未引入进程的系统中，在程序执行IO操作时，计算程序也不能执行。但在为计算程序和IO程序分别建立一个进程后，这两个进程便可并发执行。若对内存中的多个程序都分别建立一个进程，它们就可以并发执行，这样便能极大地提高系统资源的利用率，增加系统的吞吐量。</li>
</ol>
<p>所谓进程，是指在系统中能独立运行并作为资源分配的基本单位，它是由一组机器指令、数据和堆栈等组成的，是一个能独立运行的活动实体。多个进程之间可以并发执行和交换信息。</p>
<h3 id="1-4-2-共享"><a href="#1-4-2-共享" class="headerlink" title="1.4.2. 共享"></a>1.4.2. 共享</h3><p>OS环境下的资源共享或称为资源复用，是指系统中的资源可供内存中多个并发执行的进程共同使用。这里在宏观上既限定了时间（进程在内存期间），也限定了地点（内存）。</p>
<ol>
<li><p>互斥共享方式：进程A要访问某资源时，必须先提出请求。若此时该资源空闲，系统便可将之分配给请求进程A使用。<br>把这种在一段时间内只允许一个进程访问的资源，称为临界资源（或独占资源）。</p>
</li>
<li><p>同时访问方式<br>系统中还有另一类资源，允许在一段时间内由多个进程“同时”对它们进行访问。这里所谓的“同时”，在单处理机环境下是宏观意义上的，而在微观上，这些进程对该资源的访问是交替进行的。例如磁盘。</p>
</li>
</ol>
<p>并发和共享是多用户（多任务）OS的两个最基本的特征。它们又是互为存在的条件。即方面资源共享是以进程的并发执行为条件的，若系统不允许并发执行也就不存在资源共享问题；另一方面，若系统不能对资源共享实施有效管理，以协调好诸进程对共享资源的访问，也必然会影响到诸进程间并发执行的程度，甚至根本无法并发执行。</p>
<h3 id="1-4-3-虚拟"><a href="#1-4-3-虚拟" class="headerlink" title="1.4.3. 虚拟"></a>1.4.3. 虚拟</h3><ol>
<li>时分复用技术：虚拟处理机技术：虚拟设备技术。</li>
<li>空分复用技术：利用存储器的空闲空间分区域存放和运行其它的多道程序，以此来提高内存的利用率，但并不能实现在逻辑上扩大存储器容量的功能，还必须引入<strong>虚拟存储技术</strong>才能达到此目的。虚拟存储技术在本质上是实现内存的分时复用，即它可以通过分时复用内存的方式，使一道程序仅在远小于它的内存空间中运行。</li>
</ol>
<h3 id="1-4-4-异步"><a href="#1-4-4-异步" class="headerlink" title="1.4.4. 异步"></a>1.4.4. 异步</h3><p>进程是以人们不可预知的速度向前推进的，此即进程的异步性。</p>
<h2 id="1-5-操作系统的主要功能"><a href="#1-5-操作系统的主要功能" class="headerlink" title="1.5. 操作系统的主要功能"></a>1.5. 操作系统的主要功能</h2><h3 id="1-5-1-处理机管理功能"><a href="#1-5-1-处理机管理功能" class="headerlink" title="1.5.1. 处理机管理功能"></a>1.5.1. 处理机管理功能</h3><ul>
<li>进程控制：为作业创建进程、撤消（终止）已结束的进程，以及控制进程在运行过程中的状态转换；</li>
<li>进程同步：为多个进程（含线程）的运行进行协调<ul>
<li>进程互斥方式：诸进程在对临界资源进行访问</li>
<li>进程同步方式：指在相互合作去完成共同任务的诸进程间，由同步机构对它们的执行次序加以协调。例如锁。</li>
</ul>
</li>
<li>进程通信：通常在相互合作的进程之间采用直接通信方式，即由源进程利用发送命令直接将消息挂到目标进程的消息队列上，以后由目标进程利用接收命令从其消息队列中取出消息。</li>
<li>调度：<ul>
<li>作业调度：后备队列调入内存</li>
<li>进程调度：就绪队列分配处理机</li>
</ul>
</li>
</ul>
<h3 id="1-5-2-存储器管理功能"><a href="#1-5-2-存储器管理功能" class="headerlink" title="1.5.2. 存储器管理功能"></a>1.5.2. 存储器管理功能</h3><ul>
<li>内存分配；<ul>
<li>静态分配：装入时确定；</li>
<li>动态分配：允许运行中申请。</li>
</ul>
</li>
<li>内存保护：<ul>
<li>程序之间的内存空间不干扰；</li>
<li>用户程序和OS程序数据不干扰。</li>
</ul>
</li>
<li>地址映射：将程序地址空间中的逻辑地址转物理地址。</li>
<li>内存扩充：借助虚拟存储技术：<ul>
<li>请求调入功能：装入部分数据便可运行，中途调入；</li>
<li>置换功能：将暂时不用的程序和数据调至硬盘。</li>
</ul>
</li>
</ul>
<h3 id="1-5-3-设备管理功能"><a href="#1-5-3-设备管理功能" class="headerlink" title="1.5.3. 设备管理功能"></a>1.5.3. 设备管理功能</h3><ul>
<li>缓冲管理：缓和CPU与I/O设备速度不匹配的的矛盾，常见的缓冲区机制：单缓冲、双缓冲机制、公用缓冲池机制</li>
<li>设备分配：根据用户进程的IO请求、系统现有资源情况以及按照某种设备分配策略，为之分配其所需的设备。使用完后由系统回收。</li>
<li>设备处理：设备驱动程序。CPU向设备控制器发出I/O命令，完成指定的I/O操作；由CPU接收中断请求并给予迅速的响应和相应的处理。</li>
</ul>
<h3 id="1-5-4-文件管理功能"><a href="#1-5-4-文件管理功能" class="headerlink" title="1.5.4. 文件管理功能"></a>1.5.4. 文件管理功能</h3><ul>
<li>文件存储空间的管理：为每个文件分配外存空间，回收。</li>
<li>目录管理：按名存取，目录查询，文件共享。</li>
<li>文件的读写管理：利用文件指针从外存检索文件。</li>
<li>文件保护：存取控制。</li>
</ul>
<h3 id="1-5-5-OS与用户之间的接口"><a href="#1-5-5-OS与用户之间的接口" class="headerlink" title="1.5.5. OS与用户之间的接口"></a>1.5.5. OS与用户之间的接口</h3><ul>
<li>用户接口：直接或间接控制作业的命令接口<ul>
<li>联机用户接口：为联机用户提供的，包括一组键盘操作命令及命令解释程序；</li>
<li>脱机用户接口：为批处理作业的用户提供的。把需要对作业进行的控制和干预的命令事先写在作业说明书上，提交系统；</li>
<li>图形用户接口。</li>
</ul>
</li>
<li>程序接口：为用户程序访问系统资源而设置，是用户程序取得操作系统服务的唯一途径。它是由一组系统调用组成的，每一个系统调用都是一个能完成特定功能的子程序。早期的系统调用都是用汇编语言提供的，只有在用汇编语言书写的程序中才能直接使用系统调用。但在高级语言中，往往提供了与各系统调用一一对应的库函数这样。</li>
</ul>
<h3 id="1-5-6-现代操作系统的新功能"><a href="#1-5-6-现代操作系统的新功能" class="headerlink" title="1.5.6. 现代操作系统的新功能"></a>1.5.6. 现代操作系统的新功能</h3><ul>
<li>系统安全</li>
<li>网络功能</li>
<li>多媒体</li>
</ul>
<h2 id="1-6-OS结构设计"><a href="#1-6-OS结构设计" class="headerlink" title="1.6. OS结构设计"></a>1.6. OS结构设计</h2><h3 id="1-6-1-传统OS结构"><a href="#1-6-1-传统OS结构" class="headerlink" title="1.6.1. 传统OS结构"></a>1.6.1. 传统OS结构</h3><h4 id="1-6-1-1-无结构OS"><a href="#1-6-1-1-无结构OS" class="headerlink" title="1.6.1.1. 无结构OS"></a>1.6.1.1. 无结构OS</h4><p>在早期开发操作系统时，设计者只是把他的注意力放在功能的实现和获得高的效率上，缺乏首尾一致的设计思想。此时的OS是为数众多的一组过程的集合，每个过程可以任意地相互调用其它过程，致使操作系统内部既复杂又混乱，因此，这种OS是无结构的，也有人把它称为整体系统结构</p>
<h4 id="1-6-1-2-模块化结构OS"><a href="#1-6-1-2-模块化结构OS" class="headerlink" title="1.6.1.2. 模块化结构OS"></a>1.6.1.2. 模块化结构OS</h4><p>模块化程序设计技术是20世纪60年代出现的一种结构化程序设计技术。该技术“模块化”的原则来控制大型软件的复杂度。OS不再是由众多的过程直接构成的，而是按其功能精心地划分为若干个具有一定独立性和大小的模块。每个模块具有某方面的管理功能，并仔细地规定好各模块间的接口，使各模块之间能通过接口实现交互。这种设计方法称为模块-接口法。</p>
<p>模块的独立性要符合高内聚、低耦合的原则。</p>
<p>缺点：</p>
<ul>
<li>在OS设计时，对各模块间的接口规定很难满足在模块设计完成后对接口的实际需求。</li>
<li>各模块的设计齐头并进，无法寻找一个可靠的决定顺序，造成各种决定的“无序性”，这将使程序人员很难做到“设计中的每一步决定”都是建立在可靠的基础上，因此模块-接口法又被称为“无序模块法”。</li>
</ul>
<h4 id="1-6-1-3-分层式结构OS"><a href="#1-6-1-3-分层式结构OS" class="headerlink" title="1.6.1.3. 分层式结构OS"></a>1.6.1.3. 分层式结构OS</h4><p>为了将模块-接口法中“决定顺序”的无序性变为有序性，引入了有序分层法，分层法的设计任务是，在目标系统An和裸机系统（又称宿主系统）A0之间，铺设若干个层次的软件A1、A2、A3、…、An-1，使An通过An-1、An-2、…、A2、A1层，最终能在A0上运行。<br>在操作系统中，常采用自底向上法来铺设这些中间层。</p>
<p>自底向上的分层设计的基本原则是：每一步设计都建立在可靠的基础上。</p>
<p>优点：</p>
<ul>
<li>易保证系统的正确性和可靠性。</li>
<li>易扩充和易维护性。</li>
</ul>
<p>缺点：</p>
<p>分层结构的主要缺点是系统效率降低。由于层次结构是分层单向依赖的，必须在每层之间都建立层次间的通信机制，OS每执行一个功能，通常要自上而下地穿越多个层次，这无疑会增加系统的通信开销，从而导致系统效率的降低。</p>
<h3 id="1-6-2-客户服务器模式"><a href="#1-6-2-客户服务器模式" class="headerlink" title="1.6.2. 客户服务器模式"></a>1.6.2. 客户服务器模式</h3><p><strong>组成</strong></p>
<ul>
<li>客户机：每台客户机都是一个自主计算机，具有一定的处理能力。</li>
<li>服务器：通常是一台规模较大的机器，应能为网上所有的用户提供一种或多种服务。平时它一直处于工作状态，被动地等待来自客户机的请求。</li>
<li>网络系统：是用于连接所有客户机和服务器，实现它们之间通信和网络资源共享的系统。</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>数据的分布处理和存储。由于客户机具有相当强的处理和存储能力，可进行本地处理和数据的分布存储，摆脱主机瓶颈。</li>
<li>便于集中管理。较好地保障系统重要数据的“可靠”和“安全”。</li>
<li>灵活性和可扩充性。理论上，客户机和服务器的数量不受限制，可以配置多种类型的客户机和服务器。</li>
<li>易于改编应用软件。在客户服务器模式中，对于客户机程序的修改和增删，比传统集中模式要容易得多，必要时也允许由客户进行修改。</li>
</ul>
<p><strong>缺点</strong></p>
<p>基本客户/服务器模式的不足之处是存在着不可靠性和瓶颈问题。在系统仅有一个服务器时，一旦服务器故障，将导致整个网络瘫痪。当服务器在重负荷下工作时，会因忙不过来而显著地延长对用户请求的响应时间。如果在网络中配置多个服务器，并采取相应的安全措施，则这种不足可加以改善。</p>
<h3 id="1-6-3-面向对象的程序设计技术"><a href="#1-6-3-面向对象的程序设计技术" class="headerlink" title="1.6.3. 面向对象的程序设计技术"></a>1.6.3. 面向对象的程序设计技术</h3><p>略。</p>
<h3 id="1-6-4-微内核OS结构"><a href="#1-6-4-微内核OS结构" class="headerlink" title="1.6.4. 微内核OS结构"></a>1.6.4. 微内核OS结构</h3><p>有效地支持多处理机运行，适用于分布式系统环境。</p>
<h4 id="1-6-4-1-基本概念"><a href="#1-6-4-1-基本概念" class="headerlink" title="1.6.4.1. 基本概念"></a>1.6.4.1. 基本概念</h4><ul>
<li>足够小的内核：实现核心功能，并非完整功能；</li>
<li>基于C/S模式：核心之外的功能通过进程实现，运行在用户态，CS借助微内核的消息传递机制实现信息交互；</li>
</ul>
<p><img src="/images/os/kernelcs.png"></p>
<ul>
<li>应用“机制与策略分离”原理；<blockquote>
<p>所谓机制是指实现某一功能的具体执行机构，策略则是在机制的基础上借助于某些参数和算法来实现该功能的优化，或达到不同的功能目标。通常，机制处于一个系统的基层，而策略则处于系统的高层。在传统的OS中，将机制放在OS的内核的较低层，把策略放在内核的较高层次中。而在微内核操作系统中，通常将机制放在OS的微内核中。正因为如此，才有可能将内核做得很小。<br>例如，为实现进程（线程）调度功能，须在进程管理中设置一个或多个进程（线程）优先级队列，能将指定优先级进程（线程）从所在队列中取出，并将其投入执行。由于这一部分属于调度功能的机制部分，应将它放入微内核中。而对于用户（进程）如何进行分类，以及其优先级的确认方式或原则，则都是属于策略问题。可将它们放入微内核外的进程线程）管理服务器中。<br>由于进程（线程）之间的通信功能是微内核OS最基本的功能，被频繁使用，因此几乎所有的微内核OS都是将进程（线程）之间的通信功能放入微内核中。此外，还将进程的切换、线程的调度，以及多处理机之间的同步等功能也放入微内核中。</p>
</blockquote>
</li>
<li>采用面向对象技术；</li>
</ul>
<h4 id="1-6-4-2-基本功能"><a href="#1-6-4-2-基本功能" class="headerlink" title="1.6.4.2. 基本功能"></a>1.6.4.2. 基本功能</h4><p>要注意，特指的是微内核功能，而微内核实现的是使用最频繁的、最核心的功能，还可将一些功能一分为二，核心放入内核，绝大部分核外实现。</p>
<ul>
<li>进程（线程）管理：应用“机制与策略分离”原理实现；</li>
<li>低级存储器管理；</li>
<li>中断和陷入处理；</li>
</ul>
<h4 id="1-6-4-3-优缺点"><a href="#1-6-4-3-优缺点" class="headerlink" title="1.6.4.3. 优缺点"></a>1.6.4.3. 优缺点</h4><p><strong>优点</strong></p>
<ul>
<li>可扩展性：开发新的软硬件只需在核外增加专用服务器；</li>
<li>可靠性：严格测试而成；精简的API；服务器运行在用户态，出错不会影响内核和其他服务器；</li>
<li>可移植性强：所有与特定CPU和MO设备硬件有关的代码均放在内核和内核下面的硬件隐藏层中，而各种服务器均与硬件平台无关；</li>
<li>支持分布式：广泛使用消息传递通信机制，有一张进程和服务器的标识符与它们所驻留的机器之间的映射表；</li>
<li>面向对象技术。</li>
</ul>
<p><strong>缺点</strong></p>
<p>OS运行效率降低。</p>
<p>原因：效率降低最主要的原因是，在完成一次客户对操作系统提出的服务请求时，需要利用消息实现多次交互和进行用户/内核模式与上下文的多次切换。然而，在早期的OS中，用户进程在请求取得OS服务时，一般只需进行两次上下文的切换：一次是在执行系统调用后由用户态转向系统态时；另一次是在系统完成用户请求的服务后，由系统态返回用户态时。</p>
<p>在微内核OS中，由于客户和服务器、服务器和服务器之间的通信都需通过微内核，致使同样的服务请求至少需要进行四次上下文切换。</p>
<ul>
<li>客户发送请求消息给内核，以请求取得某服务器特定的服务；第二次是发生在由</li>
<li>内核把客户的请求消息发往服务器：</li>
<li>服务器完成客户请求后，把响应消息发送到内核；</li>
<li>内核将响应消息发送给客户。</li>
</ul>
<p><img src="/images/os/miniKernlPeoblem.png"></p>
<p>实际上更多，应为服务器不一定靠自身独立完成功能。</p>
<p>为了改善运行效率，可以重新把一些常用的操作系统基本功能由服务器移入微内核中，但这又会使微内核的容量明显地增大。</p>
<h1 id="2-进程的描述与控制"><a href="#2-进程的描述与控制" class="headerlink" title="2. 进程的描述与控制"></a>2. 进程的描述与控制</h1><h2 id="2-1-前趋图和程序执行"><a href="#2-1-前趋图和程序执行" class="headerlink" title="2.1. 前趋图和程序执行"></a>2.1. 前趋图和程序执行</h2><h3 id="2-1-1-前趋图"><a href="#2-1-1-前趋图" class="headerlink" title="2.1.1. 前趋图"></a>2.1.1. 前趋图</h3><p>为了能更好地描述程序的顺序和并发执行情况,我们先介绍用于描述程序执行先后顺序的前趋图。所谓前趋图是指一个有向无循环图,它用于描述进程之间执行的先后顺序。图中的每个结点可用来表示一个进程或程序段,乃至一条语句,结点间的有向边则表示两个结点之间存在的偏序或前趋关系进程(或程序之间的前趋关系可用“→”来表示,如果进程P和P存在着前趋关系,写成P1→P2,表示在P2开始执行之前P1必须完成。</p>
<h3 id="2-1-2-程序顺序执行"><a href="#2-1-2-程序顺序执行" class="headerlink" title="2.1.2. 程序顺序执行"></a>2.1.2. 程序顺序执行</h3><p>单道程序系统。<br>通常,一个应用程序由若干个程序段组成,每一个程序段完成特定的功能,它们在执行时,都需要按照某种先后次序顺序执行,仅当前一程序段执行完后,才运行后一程序段。</p>
<p><strong>特征</strong></p>
<ul>
<li>顺序性：指处理机严格地按照程序所规定的顺序执行,即每一操作必须在下一个操作开始之前结東；</li>
<li>封闭性：指程序在封闭的环境下运行,即程序运行时独占全机资源,资源的状态(除初始状态外)只有本程序才能改变它,程序一旦开始执行,其执行结果不受外界因素影响；</li>
<li>可再现性:指只要程序执行时的环境和初始条件相同,当程序重复执行时,不论它是从头到尾不停顿地执行,还是“停停走走”地执行,都可获得相同的结果。</li>
</ul>
<h3 id="2-1-3-程序并发执行"><a href="#2-1-3-程序并发执行" class="headerlink" title="2.1.3. 程序并发执行"></a>2.1.3. 程序并发执行</h3><p>多道程序技术。<br>只有在不存在前趋关系的程序之间才有可能并发执行,否则无法并发执行。</p>
<p>对于具有下述四条语句的程序段:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">S1:a:&#x3D;x+2</span><br><span class="line">S2:b:&#x3D;y+4</span><br><span class="line">S3:c:&#x3D;a+b</span><br><span class="line">S4:d:&#x3D;c+b</span><br></pre></td></tr></table></figure>
<p>可以看出:S3必须在a和b被赋值后方能执行:S4必须在S3之后执行;但S1和S2则可以并发执行,因为它们彼此互不依赖。</p>
<p><strong>特征</strong></p>
<ul>
<li>间断性。程序在并发执行时,由于它们共享系统资源,以及为完成同一项任务而相互合作,致使在这些并发执行的程序之间形成了相互制约的关系。</li>
<li>失去封闭性。当系统中存在着多个可以并发执行的程序时,系统中的各种资源将为它们所共享,而这些资源的状态也由这些程序来改变,致使其中任一程序在运行时,其环境都必然会受到其它程序的影响。</li>
<li>不可再现性。程序在并发执行时,由于失去了封闭性,也将导致其又失去可再现性。</li>
</ul>
<h2 id="2-2-进程的描述"><a href="#2-2-进程的描述" class="headerlink" title="2.2. 进程的描述"></a>2.2. 进程的描述</h2><h3 id="2-2-1-进程的定义"><a href="#2-2-1-进程的定义" class="headerlink" title="2.2.1. 进程的定义"></a>2.2.1. 进程的定义</h3><p>为了使参与并发执行的每个程序(含数据)都能独立地运行,在操作系统中必须为之配置一个专门的数据结构,称为进程控制块( Process Control block,PCB)。系统利用PCB来描述进程的基本情况和活动过程,进而控制和管理进程。这样,由程序段、相关的数据段和pCB三部分便构成了进程实体(又称进程映像)。一般情况下,我们把进程实体就简称为进程。</p>
<p>传统OS中的进程定义为:“进程是进程实体的运行过程,是系统进行资源分配和调度的一个独立单位。”</p>
<h3 id="2-2-2-进程的特征"><a href="#2-2-2-进程的特征" class="headerlink" title="2.2.2. 进程的特征"></a>2.2.2. 进程的特征</h3><ul>
<li>动态性：进程的实质是进程实体的执行过程,进程实体有一定的生命期,而程序则只是一组有序指令的集合,并存放于某种介质上,其本身并不具有活动的含义,因而是静态的。</li>
<li>并发性。是指多个进程实体同存于内存中,且能在一段时间内同时运行。引入进<br>程的目的也正是为了使其进程实体能和其它进程实体并发执行。程序(没有建立PCB)是不能参与并发执行的。</li>
<li>独立性。在传统的OS中,独立性是指进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位。凡未建立PCB的程序都不能作为一个独立的单位参与运行。</li>
<li>异步性,是指进程是按异步方式运行的,即按各自独立的、不可预知的速度向前推进。正是源于此因,才导致了传统意义上的程序若参与并发执行,会产生其结果的不可再现性。</li>
</ul>
<h2 id="2-3-进程的基本状态及转换"><a href="#2-3-进程的基本状态及转换" class="headerlink" title="2.3. 进程的基本状态及转换"></a>2.3. 进程的基本状态及转换</h2><h3 id="2-3-1-三种基本状态"><a href="#2-3-1-三种基本状态" class="headerlink" title="2.3.1. 三种基本状态"></a>2.3.1. 三种基本状态</h3><ul>
<li>就绪( Ready)状态。进程已处于准备好运行的状态,即进程已分配到除CPU以外的所有必要资源后,只要再获得CPU,便可立即执行。如果系统中有许多处于就绪状态的进程,通常将它们按一定的策略(如优先级策略)排成一个队列,称该队列为就绪队列。</li>
<li>执行( Running)状态。进程已获得CPU,其程序正在执行的状态。对任何个时刻而言,在单处理机系统中,只有一个进程处于执行状态,而在多处理机系统中,则有多个进程处于执行状态；</li>
<li>阻塞( Block)状态。正在执行的进程由于发生某事件暂时无法继续执行时的状态,亦即进程的执行受到阻塞。此时引起进程调度,OS把处理机分配给另一个就绪进程,而让受阻进程处于暂停状态,一般将这种暂停状态称为阻塞状态,有时也称为等待状态或封锁状态。通常系统将处于阻塞状态的进程也排成一个队列,称该队列为阻塞队列。</li>
</ul>
<h3 id="2-3-2-状态转换"><a href="#2-3-2-状态转换" class="headerlink" title="2.3.2. 状态转换"></a>2.3.2. 状态转换</h3><p><img src="/images/os/3status.png"></p>
<h3 id="2-3-3-创建状态和终止状态"><a href="#2-3-3-创建状态和终止状态" class="headerlink" title="2.3.3. 创建状态和终止状态"></a>2.3.3. 创建状态和终止状态</h3><ul>
<li>创建状态：如果进程所需的资源尚不能得到满足,创建工作尚未完成,进程不能被调度运行,于是把此时进程所处的状态称为创建状态。</li>
</ul>
<p>当其获得了所需的资源以及对其PCB的初始化工作完成后,便可由创建状态转入就绪状态</p>
<ul>
<li>终止状态：进当一个进程到达了自然结束点,或是出现了无法克服的错误,或是被操作系统所终结,或是被其他有终止权的进程所终结,它将进入终止状态。进入终止状态。</li>
</ul>
<p>进入终止态的进程以后不能再执行,但在操作系统中依然保留一个记录,其中保存状态码和一些计时统计数据,供其他进程收集。一旦其他进程完成了对其信息的提取之后,操作系统将删除该进程,即将其PCB清零,并将该空白PCB返还系统。</p>
<p><img src="/images/os/5status.png"></p>
<h2 id="2-4-挂起操作"><a href="#2-4-挂起操作" class="headerlink" title="2.4. 挂起操作"></a>2.4. 挂起操作</h2>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Study/">Study</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/OS/">OS</a>
    </span>
    

    </div>

    
  </div>
</article>

  
	<section id="comment" class="comment">
		<div id="gitalk-container"></div>
	</section>
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css">
	<script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script>
	<script>
		var gitalk = new Gitalk({
			clientID: '43df1f730957f2695673',
			clientSecret: '29fa4bdef022da54ce3ebc4ec844d1b5c418d42a',
			repo: 'memorykkk.github.io',
			owner: 'memorykkk',
			admin: ['memorykkk'],
			id: location.pathname,
			distractionFreeMode: false,
			createIssueManually: true,
			proxy: 'https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token',
		})

		gitalk.render('gitalk-container')
	</script>







    </main>

    <footer class="site-footer">
  <p class="site-info" style="color='#9e9e9e'">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2020-2021 Memorykk
    
	<a href="http://beian.miit.gov.cn" target="_blank">陕ICP备20005895号-1</a>
  </p>
</footer>
    
    
  </div>
</div>

</body>
</html>